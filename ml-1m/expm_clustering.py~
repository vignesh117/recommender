from user_info import *
from aff_clustering import *
from read_movie_info import *
from bandit import *
from point import *
from rating_data import *
from find_missing_rating import *

#Now create bandits 
#total_bandits = range(0,k)
movie_dict = read_genre() # This gives us the actions for each of the bandits. Here the actions are movies specific to a genre
b_keys = movie_dict.keys()
bandit_dict = {}

bandits = [] # list of bandit objects 
for b in b_keys:
	acts = movie_dict[b]
	bandit = Bandit(b,acts)
	bandit.set_count()
	bandit_dict[b] = bandit

# Getting the point class information 
points = user_info('users.dat',bandit_dict)
#print points

point_values = [x.value for x in points]

#Set the Q values for each of the points
for b in bandit_dict.values():
	for p in points:
		b.set_Q(p)

# Initialize some values
round = 0

k = 18 # Some dummy value; actually this should be the number of movies
clusters = kmeans(points,k,None)

# sample some users for testing and recommendation
sampled_users = [random.choice(points) for i in range(1,100)]


# Sample a 
def play(p,round):
	print 'Playinng round: '+str(round)
	sample_p = p
	rewards = []

	# Maintain an affinity update counter
	aff_thresh = 100
	aff_count = 0

	for i in range(2000):

		sampled_b =  sample_p.sample_bandit() #This just returns the string, Sci-fi,Horror etc
		band = bandit_dict[sampled_b] # This gives us the actual bandit

		#print sampled_b
		
		arm = band.pull_arm(sample_p)
		#print 'Arm Chosen: ' +arm
		band.get_reward(sample_p,arm,clusters)

		# Rewards are acculmuated for calculating the affinity
		rew = band.reward
		rewards.append(rew)

		#print 'Reward obtainted: '+ str(rew)
		band.update_Q(arm,sample_p)

		# You should be passing the name of the bandit
		if aff_count == aff_thresh:
			avg_rew = sum(rewards) / aff_thresh
			sample_p.update_affinity(avg_rew,band.name)
			aff_count = 0
			rewards = []
		else:
			aff_count+=1

def recommend(p):
	#print 'New affinity: ' + str(sample_p.affinity)
	#print band.Q_dict[sample_p.value[0]]
	new_band_sam = p.sample_bandit()
	new_band = bandit_dict[new_band_sam]
	new_arm = new_band.pull_arm(sample_p)
	print str(p.value)+' : ' + str(new_arm)
	print '\n'
	new_band.get_reward(p,new_arm,clusters)
	#print new_band.reward

'''
# Testing the missing value problem
movie_ratings = read_ratings('ratings.dat') # Read movie ratings
p = random.choice(points)

#Always convert userid to str
p_value = str(p.value[0])
m = ""
flag = 0
while flag == 0:
	sampled_b = p.sample_bandit()
	band = bandit_dict[sampled_b]
	arm = band.pull_arm(p)
	if movie_ratings.get(p_value).get(arm) == None:
		flag = 1
		m = arm

print "old Rating = "+ str(movie_ratings.get(p_value).get(arm))

# Find the cluster corresponing to p
cid = clusters[p_value] 
print cid

# Find the rating
rating = find_movie_rating(clusters,cid,m)
print "New rating = " +str(rating)
'''



def learn():
	for s in sample_users:

		#Sample a point and play the game
		sample_p = s 

		#play and learn the values
		play(sample_p,round)
		round+=1

		# Perform clustering 
		clusters = kmeans(points,k,clusters)

		#Play another round
		play(sample_p, round)
		round+=1

		# Another round of clustering
		clusters = kmeans(points,k,clusters)

		#Another round of play and recommend
		play(sample_p,round)

'''
# Now to generalize for unknown points
sample_points = [random.choice(points) for i in range(100)]
for s in sample_points:
	recommend(s)
'''

init()
learn()
for s in sampled_users:
	sample_p = s
#Recommendation for the known points
	for i in range(1,3):
		recommend(sample_p)
#print 'Point is: ' + str(sample_p.value[0])
#print 'Old affinity: ' + str(sample_p.affinity)
